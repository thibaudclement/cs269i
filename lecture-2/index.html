
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../lecture-1/">
      
      
        <link rel="next" href="../lecture-3/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Stable Two-Sided Matchings - Stanford CS269I Course Notes</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#stable-two-sided-matchings" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Stanford CS269I Course Notes" class="md-header__button md-logo" aria-label="Stanford CS269I Course Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Stanford CS269I Course Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Stable Two-Sided Matchings
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Stanford CS269I Course Notes" class="md-nav__button md-logo" aria-label="Stanford CS269I Course Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Stanford CS269I Course Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    One-Sided Matching and Serial Dictatorship
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Stable Two-Sided Matchings
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Stable Two-Sided Matchings
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#stable-matching" class="md-nav__link">
    <span class="md-ellipsis">
      Stable Matching
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#deferred-acceptance" class="md-nav__link">
    <span class="md-ellipsis">
      Deferred Acceptance
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#deferred-acceptance-as-a-mechanism" class="md-nav__link">
    <span class="md-ellipsis">
      Deferred Acceptance as a Mechanism
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#deferred-acceptance-in-practice" class="md-nav__link">
    <span class="md-ellipsis">
      Deferred Acceptance in Practice
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recap" class="md-nav__link">
    <span class="md-ellipsis">
      Recap
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Online Learning and Regret Minimization
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-3-2023/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Top Trading Cycles
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Equilibria in Games
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    P2P File-sharing Dilemma
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Market Equilibrium
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Market Failures
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Auctions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-9/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Prediction Markets and Information Cascades
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-9.5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Mid-Quarter Review Party
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../guest-lecture-eric-neyman/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    How to Train an AI That Doesn't Lie
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-10/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Scoring Rules
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../guest-lecture-kshipra-bhawalkar/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Incentives in Sponsored Search Auctions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lecture-11/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Proof-of-Work Blockchains
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#stable-matching" class="md-nav__link">
    <span class="md-ellipsis">
      Stable Matching
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#deferred-acceptance" class="md-nav__link">
    <span class="md-ellipsis">
      Deferred Acceptance
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#deferred-acceptance-as-a-mechanism" class="md-nav__link">
    <span class="md-ellipsis">
      Deferred Acceptance as a Mechanism
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#deferred-acceptance-in-practice" class="md-nav__link">
    <span class="md-ellipsis">
      Deferred Acceptance in Practice
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recap" class="md-nav__link">
    <span class="md-ellipsis">
      Recap
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="stable-two-sided-matchings">Stable Two-Sided Matchings</h1>
<p><em>April 2, 2025</em></p>
<p>After medical school, med students start their internship called a "residency." Each (prospective) doctor has preferences over hospitals, and each hospital has preferences over doctors. How should doctors and hospitals be matched?</p>
<p><strong>Key Nuances:</strong></p>
<ul>
<li>The biggest difference between doctor-residency matching and student-dorm matching is that we now have <strong>two-sided</strong> preferences (each doctor and hospital have preferences over each other).</li>
<li>Matching students to dorms is a <em>centralized</em> process, while matching doctors to hospitals requires incentivizing participants to use a centralized process to prevent side deals.</li>
</ul>
<h2 id="stable-matching">Stable Matching</h2>
<div class="definition">
<p><strong>Definition: Blocking Pair</strong></p>
<p>Given a match <span class="arithmatex">\(M\)</span>, the pair (doctor <span class="arithmatex">\(i\)</span>, hospital <span class="arithmatex">\(j\)</span>) forms a blocking pair if they prefer each other to their current assignments in <span class="arithmatex">\(M\)</span>.</p>
</div>
<p>For example, if Doctor <span class="arithmatex">\(n\)</span> prefers Stanford over UCSF and Stanford prefers Doctor <span class="arithmatex">\(n\)</span> over Doctor 1, who is currently matched, then (Doctor <span class="arithmatex">\(n\)</span>, Stanford) form a blocking pair. This results in an <strong>Unstable Matching</strong>.</p>
<p><strong>Note:</strong> Blocking pairs exist only in two-sided matching markets. In a 1-sided matching, we cannot have blocking pairs, because in a blocking pair, both participants need to prefer each other. In the Stanford Undergraduate Housing Problem, even though students have preferences over dorms, dorms do not have preferences over students.</p>
<div class="definition">
<p><strong>Definition: Stable Matching</strong></p>
<p>A matching <span class="arithmatex">\(M\)</span> is stable if there are no blocking pairs. Equivalently, for every unmatched pair <span class="arithmatex">\((i,j)\)</span>, either:</p>
<ul>
<li>Doctor <span class="arithmatex">\(i\)</span> prefers Hospital <span class="arithmatex">\(M(i)\)</span> over Hospital <span class="arithmatex">\(j\)</span>, or;</li>
<li>Hospital <span class="arithmatex">\(j\)</span> prefers Doctor <span class="arithmatex">\(M(j)\)</span> over Doctor <span class="arithmatex">\(i\)</span>.</li>
</ul>
</div>
<p><strong>Key Point:</strong> Stability removes incentives to deviate from the centralized matching. For instance, if you have a stable matching between doctors and hospitals, then neither doctors nor hospitals have any incentive to deviate from the matching and match outside of the process. They might as well stay in the centralized matching, because they cannot get anything better outside of the matching process.</p>
<h2 id="deferred-acceptance">Deferred Acceptance</h2>
<p>The Deferred Acceptance Algorithm is an algorithm that finds stable matchings.</p>
<p><strong>Main idea:</strong> Each doctor proposes to their favorite hospital that hasn't rejected them yet. Hospitals accept the best available candidate. If we discover a blocking pair, we switch the matching.</p>
<div class="definition">
<p><strong>Mechanism: Deferred Acceptance</strong></p>
<p>While there's an unmatched doctor <span class="arithmatex">\(i\)</span>:</p>
<ul>
<li>Doctor <span class="arithmatex">\(i\)</span> proposes to their next-favorite hospital <span class="arithmatex">\(j\)</span>.</li>
<li>If hospital <span class="arithmatex">\(j\)</span> has no match, they accept doctor <span class="arithmatex">\(i\)</span>.</li>
<li>Else, if hospital <span class="arithmatex">\(j\)</span> prefers their current match over doctor <span class="arithmatex">\(i\)</span>, doctor <span class="arithmatex">\(i\)</span> remains unmatched.</li>
<li>Else, hospital <span class="arithmatex">\(j\)</span> matches with doctor <span class="arithmatex">\(i\)</span>, releasing their previous match.</li>
</ul>
<p>The algorithm stops when everyone is matched.</p>
</div>
<div class="example">
<p><strong>Example</strong></p>
<p>Consider the following agents and their respective preferences:</p>
<ul>
<li><strong>Doctors:</strong> <span class="arithmatex">\(Alice (X, Y, Z)\)</span>, <span class="arithmatex">\(Bob (Y, X, Z)\)</span>, <span class="arithmatex">\(Charlie (Y, Z, X)\)</span>.</li>
<li><strong>Hospitals:</strong> <span class="arithmatex">\(X (Bob, Alice, Charlie)\)</span>, <span class="arithmatex">\(Y (Alice, Bob, Charlie)\)</span>, <span class="arithmatex">\(Z (Bob, Charlie, Alice)\)</span>.</li>
</ul>
<p>Stable matching result: <span class="arithmatex">\((Alice, X), (Bob, Y), (Charlie, Z)\)</span>.</p>
</div>
<p><strong>Note:</strong> No matter the order chosen to process the doctors, we always find the stable matching. </p>
<div class="theorem">
<p><strong>Theorem: Runtime of Deferred Acceptance</strong></p>
<p>Deferred Acceptance runs in <span class="arithmatex">\(O(n^2)\)</span> time.</p>
</div>
<p>This is important, because when inputs are of non-trivial size, we want to make sure the algorithm is efficient.</p>
<div class="proof">
<p><strong>Proof:</strong></p>
<ul>
<li>There are at most <span class="arithmatex">\(n^2\)</span> proposals (each doctor proposes at most to <span class="arithmatex">\(n\)</span> hospitals).</li>
<li>Each proposal is <span class="arithmatex">\(O(1)\)</span>.</li>
<li>So, the total runtime is <span class="arithmatex">\(O(n^2)\)</span>.</li>
</ul>
</div>
<p><strong>Why do we have at most <span class="arithmatex">\(n^2\)</span> iterations?</strong> A doctor never proposes to the same hospital twice (we never try to match the same pair of doctor-hospital twice), because we are going down the list of preferences. So, if there are <span class="arithmatex">\(n\)</span> doctors and <span class="arithmatex">\(n\)</span> hospitals, then there are <span class="arithmatex">\(n^2\)</span> possible doctor-hospital pairs. This is why we have at most <span class="arithmatex">\(n^2\)</span> iterations (there are instances where it really takes <span class="arithmatex">\(n^2\)</span> time).</p>
<p><strong>Why is each proposal <span class="arithmatex">\(O(1)\)</span>?</strong> We assume that doctor <span class="arithmatex">\(i\)</span> already has a ranked list of preferences (how we get the preferences is non-trivial but outside of this algorithm). On every iteration, all we do is advance to the next hospital in the list of a doctor’s preferences (for instance, in the case of <span class="arithmatex">\(Bob\)</span> above, we moved from Hospital <span class="arithmatex">\(Y\)</span> to Hospital <span class="arithmatex">\(X\)</span>). When a hospital needs to determine whether it prefers its current match <span class="arithmatex">\(i'\)</span> over <span class="arithmatex">\(i\)</span> (or not), it can use an array with the preferences of doctors (ranked): this way, it can compare the ranks in <span class="arithmatex">\(O(1)\)</span> time.</p>
<div class="theorem">
<p><strong>Theorem: Deferred Acceptance is Stable</strong></p>
<p>Given <span class="arithmatex">\(n\)</span> doctors and <span class="arithmatex">\(n\)</span> hospitals, Deferred Acceptance outputs a complete stable matching.</p>
</div>
<div class="theorem">
<p><strong>Corollary: A stable matching exists.</strong></p>
<p>(This is not obvious!)</p>
</div>
<div class="proof">
<p><strong>Proof (outline):</strong></p>
<p>We prove that Deferred Acceptance outputs a complete stable matching with three claims:</p>
<ol>
<li>The current match is stable at each iteration.</li>
<li>Once matched, hospitals remain matched.</li>
<li>At completion, everyone is matched.</li>
</ol>
<p>Therefore, no blocking pairs exist.</p>
</div>
<p><strong>How does this proof work?</strong> <em>Claim 1</em> states that we have already matched some doctors and hospitals, and we assume that the matching so far is stable. <em>Claim 2</em> states tgat once a hospital is matched, it may be matched to another doctor, but it never gets unmatched (however, doctors can get unmatched). <em>Claim 3</em> states that no doctor, and no hospital, is unmatched at the end of the matching. Since we know that the matching is stable after each iteration, and there is no one left unmatched at the end, then the matching at the end is stable.</p>
<div class="proof">
<p><strong>Proof of Claims:</strong></p>
<ul>
<li><strong>Claim 1:</strong> We assume that doctor <span class="arithmatex">\(d\)</span> and hospital <span class="arithmatex">\(h\)</span> are currently matched to other matches and they are a blocking pair. This means that <span class="arithmatex">\(d\)</span> is matched to a worse hospital, so we must have tried to match <span class="arithmatex">\(d\)</span> to <span class="arithmatex">\(h\)</span>, and we must have gone down the preference list, either because <span class="arithmatex">\(h\)</span> refused to match to <span class="arithmatex">\(d\)</span>, or because <span class="arithmatex">\(h\)</span> preferred another doctor. This means that <span class="arithmatex">\(h\)</span> must have already matched with someone better than <span class="arithmatex">\(d\)</span>. This is a contradiction with the fact that <span class="arithmatex">\((d,h)\)</span> is a blocking pair.</li>
<li><strong>Claim 2:</strong> If you look at the pseudo code of the algorithm, there is simply no command to unmatch a hospital.</li>
<li><strong>Claim 3:</strong> If we have a free doctor, then we need to have a free hospital as well. However, if we reach the end of the algorithm, <span class="arithmatex">\(d\)</span> already tried to propose to <span class="arithmatex">\(h\)</span>, but after that step, <span class="arithmatex">\(h\)</span> is matched (either because <span class="arithmatex">\(d\)</span> matches with <span class="arithmatex">\(h\)</span>, or because <span class="arithmatex">\(h\)</span> is already matched to another doctor). By <strong>Claim 2</strong>, we know that a hospital stays matched until the end of the algorithm, so <span class="arithmatex">\(h\)</span> cannot be free. This is a contradiction to <span class="arithmatex">\(h\)</span> being free at the end of the algorithm (we cannot have a <span class="arithmatex">\((d,h)\)</span> pair free).</li>
</ul>
</div>
<h2 id="deferred-acceptance-as-a-mechanism">Deferred Acceptance as a Mechanism</h2>
<p>We know that Deferred Acceptance always finds a stable matching. Is it optimal? What does optimality mean?</p>
<div class="theorem">
<p><strong>Theorem: Efficiency of Stable Matchings</strong></p>
<p>Every stable matching is Pareto-optimal.</p>
</div>
<p><strong>Reminder:</strong> An assignment <span class="arithmatex">\( A \)</span> is Pareto-optimal if for any other assignment <span class="arithmatex">\( B \)</span>, there is a participan that (strictly) prefers <span class="arithmatex">\( A \)</span> over <span class="arithmatex">\( B \)</span>.</p>
<div class="proof">
<p><strong>Proof:</strong> Any deviation from a stable matching worsens at least one participant’s outcome.</p>
</div>
<p><strong>Comment:</strong> If we take the stable matching, and any other matching (whether it is stable or not), there are going to be some doctors and/or some hospitals that prefer the stable matching over that other matching.</p>
<div class="theorem">
<p><strong>Theorem: The matching returned by the Deferred Acceptance mechanism is doctor-optimal.</strong></p>
<p>In other words, every doctor is matched to their favorite hospital possible in any stable matching.</p>
</div>
<p><strong>If we have multiple stable matchings, which one is the best one?</strong> Doctor-optimality means that every doctor gets the best hospital they can possibly get out of any stable matching. When we talked about the student-dorms 1-sided matching, it was possible that some students were happier, while others were sadder, depending on the matching (we had some trade-offs). However, here, among all stable matchings, the matching that DA outputs is the best for every single doctor simultaneously. An implication of this theorem is that the Deferred Acceptance mechanism is also doctor-strategyproof.</p>
<div class="theorem">
<p><strong>Corollary: Deferred Acceptance is doctor-strategyproof.</strong></p>
<p>Doctors cannot gain from misreporting their preferences.</p>
</div>
<div class="theorem">
<p><strong>Theorem: The matching returned by the Deferred Acceptance mechanism is hospital-worst.</strong></p>
<p>In other words, every hospital is matched to their least favorite doctor possible in any stable matching.</p>
</div>
<div class="theorem">
<p><strong>Corollary: Deferred Acceptance is NOT hospital-strategyproof.</strong></p>
<p>Hospitals can benefit from misreporting their preferences.</p>
</div>
<div class="example">
<p><strong>Example</strong></p>
<p>Consider the following agents and their respective preferences:</p>
<ul>
<li><strong>Doctors:</strong> <span class="arithmatex">\(Alice (X, Y, Z)\)</span>, <span class="arithmatex">\(Bob (Y, X, Z)\)</span>, <span class="arithmatex">\(Charlie (Y, Z, X)\)</span>.</li>
<li><strong>Hospitals:</strong> <span class="arithmatex">\(X (Bob, Alice, Charlie)\)</span>, <span class="arithmatex">\(Y (Alice, Charlie, Bob)\)</span>, <span class="arithmatex">\(Z (Bob, Charlie, Alice)\)</span>.</li>
</ul>
<p>Stable matching result: <span class="arithmatex">\((Alice, Y), (Bob, X), (Charlie, Z)\)</span>.</p>
<p>By changing their preferences over <span class="arithmatex">\(Bob\)</span> and <span class="arithmatex">\(Charlie\)</span> (compared to the previous example setup), Hospital <span class="arithmatex">\(Y\)</span> gets matched to <span class="arithmatex">\(Alice\)</span> (their top choice).</p>
</div>
<p><strong>Question 1: Does a hospital need to know the preferences of the other hospitals over the doctors to game the system?</strong></p>
<p>Yes, Hospital <span class="arithmatex">\(Y\)</span> needs to know the preferences of all other hospitals over all other doctors to game the system, otherwise, it is pretty hard to figure out how to game the system on the hospital side. Aviad does not know of a good strategy for hospitals to game the system.</p>
<p><strong>Question 2: If a doctor ranks their safety choices higher, does it help them?</strong></p>
<p>No. For instance, if a doctor prefers Stanford, but understands that their second favorite hospital may be less competitive (i.e. rank them higher as a doctor), it is still not in their best interest to rank that second hospital higher than Stanford in their preference list, because the DA is completely doctor-strategyproof.</p>
<p><strong>Question 3: Why is the DA mechanism hospital-worst?</strong></p>
<p>Because we are processing things in order of doctor preferences, and we are only using hospital preferences for tie-breaking purposes.</p>
<p><strong>Question 4: Does Pareto optimality change if we allow participants to have non-strict preferences?</strong></p>
<p>In practice, doctors do not rank all possible hospitals, and hospitals do not rank all possible doctors. The theorem statements do not hold exactly in practice (in particular for Pareto optimality if we have non-strict preferences).</p>
<p><strong>Question 5: As a doctor, if you know that a hospital is misrepresenting their preferences, is it still doctor-stragegyproof?</strong></p>
<p>From the doctor’s perspective, the hospitals submit some ranked lists of doctors, but they don’t know whether it truthful or not, so this is still doctor-stragegyproof. However, if a doctor can influence how a hospital reports their preferences, then they can game the system.</p>
<h2 id="deferred-acceptance-in-practice">Deferred Acceptance in Practice</h2>
<p><strong>Why don’t we use a DA mechanism for undergrad admissions in the US?</strong> </p>
<p>In the US, the system is very decentralized, and this is a challenge for schools, because they need to admit a number of students without knowing how many are actually going to enroll—unlike hospitals, which generally have 1 or 2 residency positions available, so if none shows up, they don’t have a doctor, and if 5 show up, they cannot pay everyone—and these are generally large numbers.</p>
<p>Also in the US, applications are holistic, which costs money, so application fees limit the number of universities students apply to.</p>
<p>In contrast, in other countries where standardized tests scores are used instead of holistic reviews, DA mechanisms can be used (such as in Brazil, China, Hungary).</p>
<p><strong>How do doctors rank hospitals?</strong></p>
<ul>
<li>1950s: DA-like algorithms initially used. At the time, there were very few female doctors (not to mention openly gay doctors).</li>
<li>1960s: Couples complicate preferences. More couples want to be near each other, i.e. doctors no longer have a ranked preference over hospitals.</li>
<li>1980s: Negative theory results on stable matching with couples. A stable matching may not exist: it is possible that there is no stable matching when you try to match couples to the same hospitals in the same cities. Deciding if a stable matching exists is an NP-complete computational problem (it is, in theory, intractable).</li>
<li>1990s: Extended DA for couples adopted.</li>
</ul>
<p><strong>How do hospitals rank doctors?</strong></p>
<ul>
<li>Interviews (costly process): hospitals strategize over which doctors to interview ("safety choices").</li>
<li>Standardized Tests (probably not any more: USMLE switched to pass/fail in January 2022).</li>
<li>Letters of recommendation, medical school evaluation, personal statement, CV.</li>
</ul>
<div class="theorem">
<p><strong>Theorem: In DA, using safety choices is never safer for hospitals.</strong></p>
<p>Formally, manipulating true ranks to move <span class="arithmatex">\(i-th\)</span> doctor ("safety choice") to a higher position cannot help a hospital match with a doctor of rank <span class="arithmatex">\(i-or-better\)</span>.</p>
</div>
<p>Hospitals also use "safety choices" after interviews: they may not rank first the candidates that they evaluate as “too good to come here.” This is particularly interesting since we have seen in doctor-proposing DA that ranking safety choices higher is never safer for hospitals (this is provable).</p>
<div class="proof">
<p><strong>Proof:</strong></p>
<ul>
<li>Until doctor <span class="arithmatex">\(i\)</span> tries to match with a hospital, manipulation has no effect.</li>
<li>After doctor <span class="arithmatex">\(i\)</span> tries to match with a hospital, they can only be replaced by a better doctor.</li>
</ul>
</div>
<p><strong>Yet, hospitals still strategically use "safety choices" when ranking doctors post interview. Why?</strong></p>
<ul>
<li>One possible explanation is ignorance of matching mechanisms and their properties (they did not take CS269I).</li>
<li>Another possible explanation is that they consider their reputation/ego. after the matching is complete, the organization that handles the matching publishes the “number needed to fill” metric, which is the lowest ranking a hospital had to go to fill their positions. This is helpful for doctors the following year to get a sense of how competitive a program is, which is therefore also a signal of how prestigious a program is. For instance, Stanford probably don’t have to be turned down by many doctors, so their number is low, while less prestigious hospitals may need to go through more doctors and have a higher number. If a hospital ranks higher doctors that they think will join them, they can reduce their “number needed to fill” metric and appear more prestigious.</li>
</ul>
<p><strong>Other DA Applications:</strong></p>
<ul>
<li><strong>Routing Network Packets:</strong> Suppose that instead of doctors and hospitals, you want to match packets to servers on the internet. When you own all the servers, you don't have to worry about them matching outside of your algorithm. This would apply to a company like Akamai, who owns a lot of servers—and it actually works better in practice than in theory (because DA is very fact in practice). Packets typically get one of the top servers, so preferences lists are truncated, and the total running time is closer to <span class="arithmatex">\(O(n)\)</span>. Given the highly distributed nature of packet routing, every packet looks for its own server. </li>
<li><strong>Stanford Marriage Pact:</strong> Matches are made between Stanford students who want to make a pact, i.e. "If we don't get married by time X, we will marry each other." DA is not used anymore (they use something closer to max weight matching instead) because in the 21st century, the graph is not bipartite, due to people having many different preferences. Stability is not a very important part of the requirement, because in practice, Stanford students spend their time looking for a partner outside of the pact/matching.</li>
</ul>
<h2 id="recap">Recap</h2>
<div class="summary">
<p><strong>Recap:</strong></p>
<ul>
<li><strong>In theory:</strong> DA in theory is Pareto-optimal among all matchings, doctor-optimal and hospital-worst among stable matchings, and doctor-strategyproof but not not hospital-strategyproof.</li>
<li><strong>In practice:</strong> DA is expensive (collecting preferences is costly, e.g. holistic admissions in US colleges and interview in hospitals) and preferences may not be captured by the model (e.g. matching couples).</li>
</ul>
</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "navigation.sections"], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"></script>
      
        <script src="../javascript/katex-init.js"></script>
      
    
  </body>
</html>